{
	"information_for_contributors": [
		"This file has been converted from https://github.com/atom/language-ruby/blob/master/grammars/ruby.cson",
		"If you want to provide a fix or improvement, please create a pull request against the original repository.",
		"Once accepted there, we are happy to receive an update request."
	],
	"version": "https://github.com/atom/language-ruby/commit/f4082a02f467f8b253449d6998226fdea0957efa",
	"name": "Ruby",
	"scopeName": "source.ruby",
	"fileTypes": [
		"Appfile",
		"Appraisals",
		"arb",
		"Berksfile",
		"Brewfile",
		"cap",
		"Capfile",
		"capfile",
		"cgi",
		"cr",
		"Dangerfile",
		"Deliverfile",
		"Fastfile",
		"fcgi",
		"gemspec",
		"Guardfile",
		"irbrc",
		"opal",
		"Podfile",
		"podspec",
		"prawn",
		"pryrc",
		"Puppetfile",
		"rabl",
		"rake",
		"Rakefile",
		"Rantfile",
		"rb",
		"rbx",
		"rjs",
		"ru",
		"ruby",
		"Schemafile",
		"Snapfile",
		"thor",
		"Thorfile",
		"Vagrantfile"
	],
	"firstLineMatch": "(?x)\n# Hashbang\n^\\#!.*(?:\\s|\\/)\n  (?:ruby|macruby|rake|jruby|rbx|ruby_executable_hooks)\n(?:$|\\s)\n|\n# Modeline\n(?i:\n  # Emacs\n  -\\*-(?:\\s*(?=[^:;\\s]+\\s*-\\*-)|(?:.*?[;\\s]|(?<=-\\*-))mode\\s*:\\s*)\n    ruby\n  (?=[\\s;]|(?<![-*])-\\*-).*?-\\*-\n  |\n  # Vim\n  (?:(?:\\s|^)vi(?:m[<=>]?\\d+|m)?|\\sex)(?=:(?=\\s*set?\\s[^\\n:]+:)|:(?!\\s*set?\\s))(?:(?:\\s|\\s*:\\s*)\\w*(?:\\s*=(?:[^\\n\\\\\\s]|\\\\.)*)?)*[\\s:](?:filetype|ft|syntax)\\s*=\n    ruby\n  (?=\\s|:|$)\n)",
	"patterns": [
		{
			"captures": {
				"1": {
					"name": "keyword.control.class.ruby"
				},
				"2": {
					"name": "entity.name.type.class.ruby"
				},
				"4": {
					"name": "entity.other.inherited-class.ruby"
				},
				"5": {
					"name": "punctuation.separator.inheritance.ruby"
				},
				"6": {
					"name": "variable.other.object.ruby"
				},
				"7": {
					"name": "punctuation.definition.variable.ruby"
				}
			},
			"match": "(?x)\n^\\s*(class)\\s+\n(\n  (\n    [.a-zA-Z0-9_:]+\n    (\\s*(<)\\s*[.a-zA-Z0-9_:]+)?   # class A < B\n  )\n  |\n  ((<<)\\s*[.a-zA-Z0-9_:]+)         # class << C\n)",
			"name": "meta.class.ruby"
		},
		{
			"captures": {
				"1": {
					"name": "keyword.control.module.ruby"
				},
				"2": {
					"name": "entity.name.type.module.ruby"
				},
				"3": {
					"name": "entity.other.inherited-class.module.first.ruby"
				},
				"4": {
					"name": "punctuation.separator.inheritance.ruby"
				},
				"5": {
					"name": "entity.other.inherited-class.module.second.ruby"
				},
				"6": {
					"name": "punctuation.separator.inheritance.ruby"
				},
				"7": {
					"name": "entity.other.inherited-class.module.third.ruby"
				},
				"8": {
					"name": "punctuation.separator.inheritance.ruby"
				}
			},
			"match": "(?x)\n^\\s*(module)\\s+\n(\n  ([A-Z]\\w*(::))?\n  ([A-Z]\\w*(::))?\n  ([A-Z]\\w*(::))*\n  [A-Z]\\w*\n)",
			"name": "meta.module.ruby"
		},
		{
			"comment": "else if is a common mistake carried over from other languages. it works if you put in a second end, but itâ€™s never what you want.",
			"match": "(?<!\\.)\\belse(\\s)+if\\b",
			"name": "invalid.deprecated.ruby"
		},
		{
			"captures": {
				"1": {
					"name": "punctuation.definition.constant.hashkey.ruby"
				}
			},
			"comment": "symbols as hash key (1.9 syntax)",
			"match": "(?>[a-zA-Z_]\\w*(?>[?!])?)(:)(?!:)",
			"name": "constant.language.symbol.hashkey.ruby"
		},
		{
			"captures": {
				"1": {
					"name": "punctuation.definition.constant.ruby"
				}
			},
			"comment": "symbols as hash key (1.8 syntax)",
			"match": "(?<!:)(:)(?>[a-zA-Z_]\\w*(?>[?!])?)(?=\\s*=>)",
			"name": "constant.language.symbol.hashkey.ruby"
		},
		{
			"comment": "everything being a reserved word, not a value and needing a 'end' is a..",
			"match": "(?<!\\.)\\b(BEGIN|begin|case|class|else|elsif|END|end|ensure|for|if|in|module|rescue|then|unless|until|when|while)\\b(?![?!])",
			"name": "keyword.control.ruby"
		},
		{
			"comment": "contextual smart pair support for block parameters",
			"match": "(?<!\\.)\\bdo\\b",
			"name": "keyword.control.start-block.ruby"
		},
		{
			"comment": "contextual smart pair support",
			"match": "(?<={)(\\s+)",
			"name": "meta.syntax.ruby.start-block"
		},
		{
			"match": "(?<!\\.)\\b(alias|alias_method|break|next|redo|retry|return|super|undef|yield)\\b(?![?!])|\\bdefined\\?|\\b(block_given|iterator)\\?",
			"name": "keyword.control.pseudo-method.ruby"
		},
		{
			"match": "\\bnil\\b(?![?!])",
			"name": "constant.language.nil.ruby"
		},
		{
			"match": "\\b(true|false)\\b(?![?!])",
			"name": "constant.language.boolean.ruby"
		},
		{
			"match": "\\b(__(FILE|LINE)__)\\b(?![?!])",
			"name": "variable.language.ruby"
		},
		{
			"match": "\\bself\\b(?![?!])",
			"name": "variable.language.self.ruby"
		},
		{
			"comment": " everything being a method but having a special function is a..",
			"match": "\\b(initialize|new|loop|include|extend|prepend|raise|fail|attr_reader|attr_writer|attr_accessor|attr|catch|throw|private|private_class_method|module_function|public|public_class_method|protected|refine|using)\\b(?![?!])",
			"name": "keyword.other.special-method.ruby"
		},
		{
			"begin": "\\b(?<!\\.|::)(require|require_relative)\\b(?![?!])",
			"captures": {
				"1": {
					"name": "keyword.other.special-method.ruby"
				}
			},
			"end": "$|(?=#|})",
			"name": "meta.require.ruby",
			"patterns": [
				{
					"include": "$self"
				}
			]
		},
		{
			"captures": {
				"1": {
					"name": "punctuation.definition.variable.ruby"
				}
			},
			"match": "(@)[a-zA-Z_]\\w*",
			"name": "variable.other.readwrite.instance.ruby"
		},
		{
			"captures": {
				"1": {
					"name": "punctuation.definition.variable.ruby"
				}
			},
			"match": "(@@)[a-zA-Z_]\\w*",
			"name": "variable.other.readwrite.class.ruby"
		},
		{
			"captures": {
				"1": {
					"name": "punctuation.definition.variable.ruby"
				}
			},
			"match": "(\\$)[a-zA-Z_]\\w*",
			"name": "variable.other.readwrite.global.ruby"
		},
		{
			"captures": {
				"1": {
					"name": "punctuation.definition.variable.ruby"
				}
			},
			"match": "(\\$)(!|@|&|`|'|\\+|\\d+|~|=|/|\\\\|,|;|\\.|<|>|_|\\*|\\$|\\?|:|\"|-[0adFiIlpv])",
			"name": "variable.other.readwrite.global.pre-defined.ruby"
		},
		{
			"begin": "\\b(ENV)\\[",
			"beginCaptures": {
				"1": {
					"name": "variable.other.constant.ruby"
				}
			},
			"end": "]",
			"name": "meta.environment-variable.ruby",
			"patterns": [
				{
					"include": "$self"
				}
			]
		},
		{
			"match": "\\b[A-Z]\\w*(?=((\\.|::)[A-Za-z]|\\[))",
			"name": "support.class.ruby"
		},
		{
			"match": "\\b((abort|at_exit|autoload|binding|callcc|caller|caller_locations|chomp|chop|eval|exec|exit|fork|format|gets|global_variables|gsub|lambda|load|local_variables|open|p|print|printf|proc|putc|puts|rand|readline|readlines|select|set_trace_func|sleep|spawn|sprintf|srand|sub|syscall|system|test|trace_var|trap|untrace_var|warn)\\b(?![?!])|autoload\\?|exit!)",
			"name": "support.function.kernel.ruby"
		},
		{
			"match": "\\b[_A-Z]\\w*\\b",
			"name": "variable.other.constant.ruby"
		},
		{
			"begin": "(?x)\n(?=def\\b)                          # optimization to help Oniguruma fail fast\n(?<=^|\\s)(def)\\s+\n(\n  (?>[a-zA-Z_]\\w*(?>\\.|::))?      # method prefix\n  (?>                               # method name\n    [a-zA-Z_]\\w*(?>[?!]|=(?!>))?\n    |\n    ===?|!=|>[>=]?|<=>|<[<=]?|[%&`/\\|]|\\*\\*?|=?~|[-+]@?|\\[]=?\n  )\n)\n\\s*(\\()",
			"beginCaptures": {
				"1": {
					"name": "keyword.control.def.ruby"
				},
				"2": {
					"name": "entity.name.function.ruby"
				},
				"3": {
					"name": "punctuation.definition.parameters.ruby"
				}
			},
			"comment": "The method pattern comes from the symbol pattern. See there for an explanation.",
			"end": "\\)",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.parameters.ruby"
				}
			},
			"name": "meta.function.method.with-arguments.ruby",
			"patterns": [
				{
					"begin": "(?![\\s,)])",
					"end": "(?=,|\\)\\s*$)",
					"patterns": [
						{
							"captures": {
								"1": {
									"name": "storage.type.variable.ruby"
								},
								"2": {
									"name": "constant.language.symbol.hashkey.parameter.function.ruby"
								},
								"3": {
									"name": "punctuation.definition.constant.hashkey.ruby"
								},
								"4": {
									"name": "variable.parameter.function.ruby"
								}
							},
							"match": "\\G([&*]?)(?:([_a-zA-Z]\\w*(:))|([_a-zA-Z]\\w*))"
						},
						{
							"include": "$self"
						}
					]
				}
			]
		},
		{
			"begin": "(?x)\n(?=def\\b)                          # optimization to help Oniguruma fail fast\n(?<=^|\\s)(def)\\s+\n(\n  (?>[a-zA-Z_]\\w*(?>\\.|::))?      # method prefix\n  (?>                               # method name\n    [a-zA-Z_]\\w*(?>[?!]|=(?!>))?\n    |\n    ===?|!=|>[>=]?|<=>|<[<=]?|[%&`/\\|]|\\*\\*?|=?~|[-+]@?|\\[]=?\n  )\n)\n[ \\t]\n(?=[ \\t]*[^\\s#;])                 # make sure the following is not comment",
			"beginCaptures": {
				"1": {
					"name": "keyword.control.def.ruby"
				},
				"2": {
					"name": "entity.name.function.ruby"
				}
			},
			"comment": "same as the previous rule, but without parentheses around the arguments",
			"end": "$",
			"name": "meta.function.method.with-arguments.ruby",
			"patterns": [
				{
					"begin": "(?![\\s,])",
					"end": "(?=,|$)",
					"patterns": [
						{
							"captures": {
								"1": {
									"name": "storage.type.variable.ruby"
								},
								"2": {
									"name": "constant.language.symbol.hashkey.parameter.function.ruby"
								},
								"3": {
									"name": "punctuation.definition.constant.hashkey.ruby"
								},
								"4": {
									"name": "variable.parameter.function.ruby"
								}
							},
							"match": "\\G([&*]?)(?:([_a-zA-Z]\\w*(:))|([_a-zA-Z]\\w*))"
						},
						{
							"include": "$self"
						}
					]
				}
			]
		},
		{
			"captures": {
				"1": {
					"name": "keyword.control.def.ruby"
				},
				"3": {
					"name": "entity.name.function.ruby"
				}
			},
			"comment": " the optional name is just to catch the def also without a method-name",
			"match": "(?x)\n(?=def\\b)                            # optimization to help Oniguruma fail fast\n(?<=^|\\s)(def)\\b\n(\n  \\s+\n  (\n    (?>[a-zA-Z_]\\w*(?>\\.|::))?      # method prefix\n    (?>                               # method name\n      [a-zA-Z_]\\w*(?>[?!]|=(?!>))?\n      |\n      ===?|!=|>[>=]?|<=>|<[<=]?|[%&`/\\|]|\\*\\*?|=?~|[-+]@?|\\[]=?\n    )\n  )\n)?",
			"name": "meta.function.method.without-arguments.ruby"
		},
		{
			"match": "(?x)\n\\b\n(\n  [\\d](?>_?\\d)*                             # 100_000\n  (\\.(?![^[:space:][:digit:]])(?>_?\\d)*)?   # fractional part\n  ([eE][-+]?\\d(?>_?\\d)*)?                   # 1.23e-4\n  |\n  0\n  (?:\n    [xX]\\h(?>_?\\h)*|\n    [oO]?[0-7](?>_?[0-7])*|\n    [bB][01](?>_?[01])*|\n    [dD]\\d(?>_?\\d)*\n  )                                           # A base indicator can only be used with an integer\n)\\b",
			"name": "constant.numeric.ruby"
		},
		{
			"begin": ":'",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.symbol.begin.ruby"
				}
			},
			"comment": "symbol literal with '' delimitor",
			"end": "'",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.symbol.end.ruby"
				}
			},
			"name": "constant.language.symbol.ruby",
			"patterns": [
				{
					"match": "\\\\['\\\\]",
					"name": "constant.character.escape.ruby"
				}
			]
		},
		{
			"begin": ":\"",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.symbol.begin.ruby"
				}
			},
			"comment": "symbol literal with \"\" delimitor",
			"end": "\"",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.symbol.end.ruby"
				}
			},
			"name": "constant.language.symbol.interpolated.ruby",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				}
			]
		},
		{
			"comment": "Needs higher precidence than regular expressions.",
			"match": "(?<!\\()/=",
			"name": "keyword.operator.assignment.augmented.ruby"
		},
		{
			"begin": "'",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.string.begin.ruby"
				}
			},
			"comment": "string literal with '' delimitor",
			"end": "'",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.string.end.ruby"
				}
			},
			"name": "string.quoted.single.ruby",
			"patterns": [
				{
					"match": "\\\\'|\\\\\\\\",
					"name": "constant.character.escape.ruby"
				}
			]
		},
		{
			"begin": "\"",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.string.begin.ruby"
				}
			},
			"comment": "string literal with interpolation and \"\" delimitor",
			"end": "\"",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.string.end.ruby"
				}
			},
			"name": "string.quoted.double.interpolated.ruby",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				}
			]
		},
		{
			"begin": "`",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.string.begin.ruby"
				}
			},
			"comment": "execute string (allows for interpolation)",
			"end": "`",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.string.end.ruby"
				}
			},
			"name": "string.interpolated.ruby",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				}
			]
		},
		{
			"begin": "(?x)\n(?<![\\w)])((/))(?![?*+])\n(?=\n  (?:\\\\/|[^/])*+          # Do NOT change the order\n  /[eimnosux]*\\s*\n  (?:\n    [)\\]}#.,?:]|\\|\\||&&|<=>|=>|==|=~|!~|!=|;|$|\n    if|else|elsif|then|do|end|unless|while|until|or|and\n  )\n  |\n  $\n)",
			"captures": {
				"1": {
					"name": "string.regexp.interpolated.ruby"
				},
				"2": {
					"name": "punctuation.section.regexp.ruby"
				}
			},
			"comment": "regular expression literal with interpolation",
			"contentName": "string.regexp.interpolated.ruby",
			"end": "((/[eimnosux]*))",
			"patterns": [
				{
					"include": "#regex_sub"
				}
			]
		},
		{
			"begin": "%r{",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.regexp.begin.ruby"
				}
			},
			"end": "}[eimnosux]*",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.regexp.end.ruby"
				}
			},
			"name": "string.regexp.interpolated.ruby",
			"patterns": [
				{
					"include": "#regex_sub"
				},
				{
					"include": "#nest_curly_r"
				}
			]
		},
		{
			"begin": "%r\\[",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.regexp.begin.ruby"
				}
			},
			"end": "][eimnosux]*",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.regexp.end.ruby"
				}
			},
			"name": "string.regexp.interpolated.ruby",
			"patterns": [
				{
					"include": "#regex_sub"
				},
				{
					"include": "#nest_brackets_r"
				}
			]
		},
		{
			"begin": "%r\\(",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.regexp.begin.ruby"
				}
			},
			"end": "\\)[eimnosux]*",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.regexp.end.ruby"
				}
			},
			"name": "string.regexp.interpolated.ruby",
			"patterns": [
				{
					"include": "#regex_sub"
				},
				{
					"include": "#nest_parens_r"
				}
			]
		},
		{
			"begin": "%r<",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.regexp.begin.ruby"
				}
			},
			"end": ">[eimnosux]*",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.regexp.end.ruby"
				}
			},
			"name": "string.regexp.interpolated.ruby",
			"patterns": [
				{
					"include": "#regex_sub"
				},
				{
					"include": "#nest_ltgt_r"
				}
			]
		},
		{
			"begin": "%r([^\\w])",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.regexp.begin.ruby"
				}
			},
			"end": "\\1[eimnosux]*",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.regexp.end.ruby"
				}
			},
			"name": "string.regexp.interpolated.ruby",
			"patterns": [
				{
					"include": "#regex_sub"
				}
			]
		},
		{
			"begin": "%I\\[",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.array.begin.ruby"
				}
			},
			"end": "]",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.array.end.ruby"
				}
			},
			"name": "constant.language.symbol.interpolated.ruby",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				},
				{
					"include": "#nest_brackets_i"
				}
			]
		},
		{
			"begin": "%I\\(",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.array.begin.ruby"
				}
			},
			"end": "\\)",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.array.end.ruby"
				}
			},
			"name": "constant.language.symbol.interpolated.ruby",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				},
				{
					"include": "#nest_parens_i"
				}
			]
		},
		{
			"begin": "%I<",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.array.begin.ruby"
				}
			},
			"end": ">",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.array.end.ruby"
				}
			},
			"name": "constant.language.symbol.interpolated.ruby",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				},
				{
					"include": "#nest_ltgt_i"
				}
			]
		},
		{
			"begin": "%I{",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.array.begin.ruby"
				}
			},
			"end": "}",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.array.end.ruby"
				}
			},
			"name": "constant.language.symbol.interpolated.ruby",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				},
				{
					"include": "#nest_curly_i"
				}
			]
		},
		{
			"begin": "%I([^\\w])",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.array.begin.ruby"
				}
			},
			"end": "\\1",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.array.end.ruby"
				}
			},
			"name": "constant.language.symbol.interpolated.ruby",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				}
			]
		},
		{
			"begin": "%i\\[",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.array.begin.ruby"
				}
			},
			"end": "]",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.array.end.ruby"
				}
			},
			"name": "constant.language.symbol.ruby",
			"patterns": [
				{
					"match": "\\\\]|\\\\\\\\",
					"name": "constant.character.escape.ruby"
				},
				{
					"include": "#nest_brackets"
				}
			]
		},
		{
			"begin": "%i\\(",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.array.begin.ruby"
				}
			},
			"end": "\\)",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.array.end.ruby"
				}
			},
			"name": "constant.language.symbol.ruby",
			"patterns": [
				{
					"match": "\\\\\\)|\\\\\\\\",
					"name": "constant.character.escape.ruby"
				},
				{
					"include": "#nest_parens"
				}
			]
		},
		{
			"begin": "%i<",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.array.begin.ruby"
				}
			},
			"end": ">",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.array.end.ruby"
				}
			},
			"name": "constant.language.symbol.ruby",
			"patterns": [
				{
					"match": "\\\\>|\\\\\\\\",
					"name": "constant.character.escape.ruby"
				},
				{
					"include": "#nest_ltgt"
				}
			]
		},
		{
			"begin": "%i{",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.array.begin.ruby"
				}
			},
			"end": "}",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.array.end.ruby"
				}
			},
			"name": "constant.language.symbol.ruby",
			"patterns": [
				{
					"match": "\\\\}|\\\\\\\\",
					"name": "constant.character.escape.ruby"
				},
				{
					"include": "#nest_curly"
				}
			]
		},
		{
			"begin": "%i([^\\w])",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.array.begin.ruby"
				}
			},
			"end": "\\1",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.array.end.ruby"
				}
			},
			"name": "constant.language.symbol.ruby",
			"patterns": [
				{
					"comment": "Cant be named because its not neccesarily an escape.",
					"match": "\\\\."
				}
			]
		},
		{
			"begin": "%W\\[",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.array.begin.ruby"
				}
			},
			"end": "]",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.array.end.ruby"
				}
			},
			"name": "string.quoted.other.interpolated.ruby",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				},
				{
					"include": "#nest_brackets_i"
				}
			]
		},
		{
			"begin": "%W\\(",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.array.begin.ruby"
				}
			},
			"end": "\\)",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.array.end.ruby"
				}
			},
			"name": "string.quoted.other.interpolated.ruby",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				},
				{
					"include": "#nest_parens_i"
				}
			]
		},
		{
			"begin": "%W<",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.array.begin.ruby"
				}
			},
			"end": ">",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.array.end.ruby"
				}
			},
			"name": "string.quoted.other.interpolated.ruby",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				},
				{
					"include": "#nest_ltgt_i"
				}
			]
		},
		{
			"begin": "%W{",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.array.begin.ruby"
				}
			},
			"end": "}",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.array.end.ruby"
				}
			},
			"name": "string.quoted.other.interpolated.ruby",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				},
				{
					"include": "#nest_curly_i"
				}
			]
		},
		{
			"begin": "%W([^\\w])",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.array.begin.ruby"
				}
			},
			"end": "\\1",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.array.end.ruby"
				}
			},
			"name": "string.quoted.other.interpolated.ruby",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				}
			]
		},
		{
			"begin": "%w\\[",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.array.begin.ruby"
				}
			},
			"end": "]",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.array.end.ruby"
				}
			},
			"name": "string.quoted.other.ruby",
			"patterns": [
				{
					"match": "\\\\]|\\\\\\\\",
					"name": "constant.character.escape.ruby"
				},
				{
					"include": "#nest_brackets"
				}
			]
		},
		{
			"begin": "%w\\(",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.array.begin.ruby"
				}
			},
			"end": "\\)",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.array.end.ruby"
				}
			},
			"name": "string.quoted.other.ruby",
			"patterns": [
				{
					"match": "\\\\\\)|\\\\\\\\",
					"name": "constant.character.escape.ruby"
				},
				{
					"include": "#nest_parens"
				}
			]
		},
		{
			"begin": "%w<",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.array.begin.ruby"
				}
			},
			"end": ">",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.array.end.ruby"
				}
			},
			"name": "string.quoted.other.ruby",
			"patterns": [
				{
					"match": "\\\\>|\\\\\\\\",
					"name": "constant.character.escape.ruby"
				},
				{
					"include": "#nest_ltgt"
				}
			]
		},
		{
			"begin": "%w{",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.array.begin.ruby"
				}
			},
			"end": "}",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.array.end.ruby"
				}
			},
			"name": "string.quoted.other.ruby",
			"patterns": [
				{
					"match": "\\\\}|\\\\\\\\",
					"name": "constant.character.escape.ruby"
				},
				{
					"include": "#nest_curly"
				}
			]
		},
		{
			"begin": "%w([^\\w])",
			"beginCaptures": {
				"0": {
					"name": "punctuation.section.array.begin.ruby"
				}
			},
			"end": "\\1",
			"endCaptures": {
				"0": {
					"name": "punctuation.section.array.end.ruby"
				}
			},
			"name": "string.quoted.other.ruby",
			"patterns": [
				{
					"comment": "Cant be named because its not neccesarily an escape.",
					"match": "\\\\."
				}
			]
		},
		{
			"begin": "%[Qx]?\\(",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.string.begin.ruby"
				}
			},
			"end": "\\)",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.string.end.ruby"
				}
			},
			"name": "string.quoted.other.interpolated.ruby",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				},
				{
					"include": "#nest_parens_i"
				}
			]
		},
		{
			"begin": "%[Qx]?\\[",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.string.begin.ruby"
				}
			},
			"end": "]",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.string.end.ruby"
				}
			},
			"name": "string.quoted.other.interpolated.ruby",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				},
				{
					"include": "#nest_brackets_i"
				}
			]
		},
		{
			"begin": "%[Qx]?{",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.string.begin.ruby"
				}
			},
			"end": "}",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.string.end.ruby"
				}
			},
			"name": "string.quoted.other.interpolated.ruby",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				},
				{
					"include": "#nest_curly_i"
				}
			]
		},
		{
			"begin": "%[Qx]?<",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.string.begin.ruby"
				}
			},
			"end": ">",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.string.end.ruby"
				}
			},
			"name": "string.quoted.other.interpolated.ruby",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				},
				{
					"include": "#nest_ltgt_i"
				}
			]
		},
		{
			"begin": "%[Qx]([^\\w])",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.string.begin.ruby"
				}
			},
			"end": "\\1",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.string.end.ruby"
				}
			},
			"name": "string.quoted.other.interpolated.ruby",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				}
			]
		},
		{
			"begin": "%([^\\w\\s=])",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.string.begin.ruby"
				}
			},
			"end": "\\1",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.string.end.ruby"
				}
			},
			"name": "string.quoted.other.interpolated.ruby",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				}
			]
		},
		{
			"begin": "%q\\(",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.string.begin.ruby"
				}
			},
			"end": "\\)",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.string.end.ruby"
				}
			},
			"name": "string.quoted.other.ruby",
			"patterns": [
				{
					"match": "\\\\\\)|\\\\\\\\",
					"name": "constant.character.escape.ruby"
				},
				{
					"include": "#nest_parens"
				}
			]
		},
		{
			"begin": "%q<",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.string.begin.ruby"
				}
			},
			"end": ">",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.string.end.ruby"
				}
			},
			"name": "string.quoted.other.ruby",
			"patterns": [
				{
					"match": "\\\\>|\\\\\\\\",
					"name": "constant.character.escape.ruby"
				},
				{
					"include": "#nest_ltgt"
				}
			]
		},
		{
			"begin": "%q\\[",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.string.begin.ruby"
				}
			},
			"end": "]",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.string.end.ruby"
				}
			},
			"name": "string.quoted.other.ruby",
			"patterns": [
				{
					"match": "\\\\]|\\\\\\\\",
					"name": "constant.character.escape.ruby"
				},
				{
					"include": "#nest_brackets"
				}
			]
		},
		{
			"begin": "%q{",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.string.begin.ruby"
				}
			},
			"end": "}",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.string.end.ruby"
				}
			},
			"name": "string.quoted.other.ruby",
			"patterns": [
				{
					"match": "\\\\}|\\\\\\\\",
					"name": "constant.character.escape.ruby"
				},
				{
					"include": "#nest_curly"
				}
			]
		},
		{
			"begin": "%q([^\\w])",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.string.begin.ruby"
				}
			},
			"end": "\\1",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.string.end.ruby"
				}
			},
			"name": "string.quoted.other.ruby",
			"patterns": [
				{
					"comment": "Cant be named because its not neccesarily an escape.",
					"match": "\\\\."
				}
			]
		},
		{
			"begin": "%s\\(",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.symbol.begin.ruby"
				}
			},
			"end": "\\)",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.symbol.end.ruby"
				}
			},
			"name": "constant.language.symbol.ruby",
			"patterns": [
				{
					"match": "\\\\\\)|\\\\\\\\",
					"name": "constant.character.escape.ruby"
				},
				{
					"include": "#nest_parens"
				}
			]
		},
		{
			"begin": "%s<",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.symbol.begin.ruby"
				}
			},
			"end": ">",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.symbol.end.ruby"
				}
			},
			"name": "constant.language.symbol.ruby",
			"patterns": [
				{
					"match": "\\\\>|\\\\\\\\",
					"name": "constant.character.escape.ruby"
				},
				{
					"include": "#nest_ltgt"
				}
			]
		},
		{
			"begin": "%s\\[",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.symbol.begin.ruby"
				}
			},
			"end": "]",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.symbol.end.ruby"
				}
			},
			"name": "constant.language.symbol.ruby",
			"patterns": [
				{
					"match": "\\\\]|\\\\\\\\",
					"name": "constant.character.escape.ruby"
				},
				{
					"include": "#nest_brackets"
				}
			]
		},
		{
			"begin": "%s{",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.symbol.begin.ruby"
				}
			},
			"end": "}",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.symbol.end.ruby"
				}
			},
			"name": "constant.language.symbol.ruby",
			"patterns": [
				{
					"match": "\\\\}|\\\\\\\\",
					"name": "constant.character.escape.ruby"
				},
				{
					"include": "#nest_curly"
				}
			]
		},
		{
			"begin": "%s([^\\w])",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.symbol.begin.ruby"
				}
			},
			"end": "\\1",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.symbol.end.ruby"
				}
			},
			"name": "constant.language.symbol.ruby",
			"patterns": [
				{
					"comment": "Cant be named because its not neccesarily an escape.",
					"match": "\\\\."
				}
			]
		},
		{
			"captures": {
				"1": {
					"name": "punctuation.definition.constant.ruby"
				}
			},
			"comment": "symbols",
			"match": "(?x)\n(?<!:)(:)\n(?>\n  [$a-zA-Z_]\\w*(?>[?!]|=(?![>=]))?\n  |\n  ===?|<=>|>[>=]?|<[<=]?|[%&`/\\|]|\\*\\*?|=?~|[-+]@?|\\[]=?\n  |\n  @@?[a-zA-Z_]\\w*\n)",
			"name": "constant.language.symbol.ruby"
		},
		{
			"begin": "^=begin",
			"captures": {
				"0": {
					"name": "punctuation.definition.comment.ruby"
				}
			},
			"comment": "multiline comments",
			"end": "^=end",
			"name": "comment.block.documentation.ruby"
		},
		{
			"include": "#yard"
		},
		{
			"begin": "(^[ \\t]+)?(?=#)",
			"beginCaptures": {
				"1": {
					"name": "punctuation.whitespace.comment.leading.ruby"
				}
			},
			"end": "(?!\\G)",
			"patterns": [
				{
					"begin": "#",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.comment.ruby"
						}
					},
					"end": "\\n",
					"name": "comment.line.number-sign.ruby"
				}
			]
		},
		{
			"comment": "\n\t\t\tmatches questionmark-letters.\n\n\t\t\texamples (1st alternation = hex):\n\t\t\t?\\x1     ?\\x61\n\n\t\t\texamples (2nd alternation = octal):\n\t\t\t?\\0      ?\\07     ?\\017\n\n\t\t\texamples (3rd alternation = escaped):\n\t\t\t?\\n      ?\\b\n\n\t\t\texamples (4th alternation = meta-ctrl):\n\t\t\t?\\C-a    ?\\M-a    ?\\C-\\M-\\C-\\M-a\n\n\t\t\texamples (4th alternation = normal):\n\t\t\t?a       ?A       ?0 \n\t\t\t?*       ?\"       ?( \n\t\t\t?.       ?#\n\t\t\t\n\t\t\t\n\t\t\tthe negative lookbehind prevents against matching\n\t\t\tp(42.tainted?)\n\t\t\t",
			"match": "(?<!\\w)\\?(\\\\(x\\h{1,2}(?!\\h)\\b|0[0-7]{0,2}(?![0-7])\\b|[^x0MC])|(\\\\[MC]-)+\\w|[^\\s\\\\])",
			"name": "constant.numeric.ruby"
		},
		{
			"begin": "^__END__\\n",
			"captures": {
				"0": {
					"name": "string.unquoted.program-block.ruby"
				}
			},
			"comment": "__END__ marker",
			"contentName": "text.plain",
			"end": "(?=not)impossible",
			"patterns": [
				{
					"begin": "(?=<?xml|<(?i:html\\b)|!DOCTYPE (?i:html\\b))",
					"end": "(?=not)impossible",
					"name": "text.html.embedded.ruby",
					"patterns": [
						{
							"include": "text.html.basic"
						}
					]
				}
			]
		},
		{
			"begin": "(?=(?><<[-~]([\"'`]?)((?:[_\\w]+_|)HTML)\\b\\1))",
			"comment": "Heredoc with embedded html",
			"end": "(?!\\G)",
			"name": "meta.embedded.block.html",
			"patterns": [
				{
					"begin": "(?><<[-~]([\"'`]?)((?:[_\\w]+_|)HTML)\\b\\1)",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.string.begin.ruby"
						}
					},
					"contentName": "text.html",
					"end": "^\\s*\\2$\\n?",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.string.end.ruby"
						}
					},
					"name": "string.unquoted.heredoc.ruby",
					"patterns": [
						{
							"include": "#heredoc"
						},
						{
							"include": "#interpolated_ruby"
						},
						{
							"include": "text.html.basic"
						},
						{
							"include": "#escaped_char"
						}
					]
				}
			]
		},
		{
			"begin": "(?=(?><<[-~]([\"'`]?)((?:[_\\w]+_|)XML)\\b\\1))",
			"comment": "Heredoc with embedded xml",
			"end": "(?!\\G)",
			"name": "meta.embedded.block.xml",
			"patterns": [
				{
					"begin": "(?><<[-~]([\"'`]?)((?:[_\\w]+_|)XML)\\b\\1)",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.string.begin.ruby"
						}
					},
					"contentName": "text.xml",
					"end": "^\\s*\\2$\\n?",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.string.end.ruby"
						}
					},
					"name": "string.unquoted.heredoc.ruby",
					"patterns": [
						{
							"include": "#heredoc"
						},
						{
							"include": "#interpolated_ruby"
						},
						{
							"include": "text.xml"
						},
						{
							"include": "#escaped_char"
						}
					]
				}
			]
		},
		{
			"begin": "(?=(?><<[-~]([\"'`]?)((?:[_\\w]+_|)SQL)\\b\\1))",
			"comment": "Heredoc with embedded sql",
			"end": "(?!\\G)",
			"name": "meta.embedded.block.sql",
			"patterns": [
				{
					"begin": "(?><<[-~]([\"'`]?)((?:[_\\w]+_|)SQL)\\b\\1)",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.string.begin.ruby"
						}
					},
					"contentName": "source.sql",
					"end": "^\\s*\\2$\\n?",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.string.end.ruby"
						}
					},
					"name": "string.unquoted.heredoc.ruby",
					"patterns": [
						{
							"include": "#heredoc"
						},
						{
							"include": "#interpolated_ruby"
						},
						{
							"include": "source.sql"
						},
						{
							"include": "#escaped_char"
						}
					]
				}
			]
		},
		{
			"begin": "(?=(?><<[-~]([\"'`]?)((?:[_\\w]+_|)GRAPHQL)\\b\\1))",
			"comment": "Heredoc with embedded GraphQL",
			"end": "(?!\\G)",
			"name": "meta.embedded.block.graphql",
			"patterns": [
				{
					"begin": "(?><<[-~]([\"'`]?)((?:[_\\w]+_|)GRAPHQL)\\b\\1)",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.string.begin.ruby"
						}
					},
					"contentName": "source.graphql",
					"end": "^\\s*\\2$\\n?",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.string.end.ruby"
						}
					},
					"name": "string.unquoted.heredoc.ruby",
					"patterns": [
						{
							"include": "#heredoc"
						},
						{
							"include": "#interpolated_ruby"
						},
						{
							"include": "source.graphql"
						},
						{
							"include": "#escaped_char"
						}
					]
				}
			]
		},
		{
			"begin": "(?=(?><<[-~]([\"'`]?)((?:[_\\w]+_|)CSS)\\b\\1))",
			"comment": "Heredoc with embedded css",
			"end": "(?!\\G)",
			"name": "meta.embedded.block.css",
			"patterns": [
				{
					"begin": "(?><<[-~]([\"'`]?)((?:[_\\w]+_|)CSS)\\b\\1)",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.string.begin.ruby"
						}
					},
					"contentName": "source.css",
					"end": "^\\s*\\2$\\n?",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.string.end.ruby"
						}
					},
					"name": "string.unquoted.heredoc.ruby",
					"patterns": [
						{
							"include": "#heredoc"
						},
						{
							"include": "#interpolated_ruby"
						},
						{
							"include": "source.css"
						},
						{
							"include": "#escaped_char"
						}
					]
				}
			]
		},
		{
			"begin": "(?=(?><<[-~]([\"'`]?)((?:[_\\w]+_|)CPP)\\b\\1))",
			"comment": "Heredoc with embedded c++",
			"end": "(?!\\G)",
			"name": "meta.embedded.block.cpp",
			"patterns": [
				{
					"begin": "(?><<[-~]([\"'`]?)((?:[_\\w]+_|)CPP)\\b\\1)",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.string.begin.ruby"
						}
					},
					"contentName": "source.cpp",
					"end": "^\\s*\\2$\\n?",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.string.end.ruby"
						}
					},
					"name": "string.unquoted.heredoc.ruby",
					"patterns": [
						{
							"include": "#heredoc"
						},
						{
							"include": "#interpolated_ruby"
						},
						{
							"include": "source.cpp"
						},
						{
							"include": "#escaped_char"
						}
					]
				}
			]
		},
		{
			"begin": "(?=(?><<[-~]([\"'`]?)((?:[_\\w]+_|)C)\\b\\1))",
			"comment": "Heredoc with embedded c",
			"end": "(?!\\G)",
			"name": "meta.embedded.block.c",
			"patterns": [
				{
					"begin": "(?><<[-~]([\"'`]?)((?:[_\\w]+_|)C)\\b\\1)",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.string.begin.ruby"
						}
					},
					"contentName": "source.c",
					"end": "^\\s*\\2$\\n?",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.string.end.ruby"
						}
					},
					"name": "string.unquoted.heredoc.ruby",
					"patterns": [
						{
							"include": "#heredoc"
						},
						{
							"include": "#interpolated_ruby"
						},
						{
							"include": "source.c"
						},
						{
							"include": "#escaped_char"
						}
					]
				}
			]
		},
		{
			"begin": "(?=(?><<[-~]([\"'`]?)((?:[_\\w]+_|)(?:JS|JAVASCRIPT))\\b\\1))",
			"comment": "Heredoc with embedded javascript",
			"end": "(?!\\G)",
			"name": "meta.embedded.block.js",
			"patterns": [
				{
					"begin": "(?><<[-~]([\"'`]?)((?:[_\\w]+_|)(?:JS|JAVASCRIPT))\\b\\1)",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.string.begin.ruby"
						}
					},
					"contentName": "source.js",
					"end": "^\\s*\\2$\\n?",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.string.end.ruby"
						}
					},
					"name": "string.unquoted.heredoc.ruby",
					"patterns": [
						{
							"include": "#heredoc"
						},
						{
							"include": "#interpolated_ruby"
						},
						{
							"include": "source.js"
						},
						{
							"include": "#escaped_char"
						}
					]
				}
			]
		},
		{
			"begin": "(?=(?><<[-~]([\"'`]?)((?:[_\\w]+_|)JQUERY)\\b\\1))",
			"comment": "Heredoc with embedded jQuery javascript",
			"end": "(?!\\G)",
			"name": "meta.embedded.block.js.jquery",
			"patterns": [
				{
					"begin": "(?><<[-~]([\"'`]?)((?:[_\\w]+_|)JQUERY)\\b\\1)",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.string.begin.ruby"
						}
					},
					"contentName": "source.js.jquery",
					"end": "^\\s*\\2$\\n?",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.string.end.ruby"
						}
					},
					"name": "string.unquoted.heredoc.ruby",
					"patterns": [
						{
							"include": "#heredoc"
						},
						{
							"include": "#interpolated_ruby"
						},
						{
							"include": "source.js.jquery"
						},
						{
							"include": "#escaped_char"
						}
					]
				}
			]
		},
		{
			"begin": "(?=(?><<[-~]([\"'`]?)((?:[_\\w]+_|)(?:SH|SHELL))\\b\\1))",
			"comment": "Heredoc with embedded shell",
			"end": "(?!\\G)",
			"name": "meta.embedded.block.shell",
			"patterns": [
				{
					"begin": "(?><<[-~]([\"'`]?)((?:[_\\w]+_|)(?:SH|SHELL))\\b\\1)",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.string.begin.ruby"
						}
					},
					"contentName": "source.shell",
					"end": "^\\s*\\2$\\n?",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.string.end.ruby"
						}
					},
					"name": "string.unquoted.heredoc.ruby",
					"patterns": [
						{
							"include": "#heredoc"
						},
						{
							"include": "#interpolated_ruby"
						},
						{
							"include": "source.shell"
						},
						{
							"include": "#escaped_char"
						}
					]
				}
			]
		},
		{
			"begin": "(?=(?><<[-~]([\"'`]?)((?:[_\\w]+_|)LUA)\\b\\1))",
			"comment": "Heredoc with embedded lua",
			"end": "(?!\\G)",
			"name": "meta.embedded.block.lua",
			"patterns": [
				{
					"begin": "(?><<[-~]([\"'`]?)((?:[_\\w]+_|)LUA)\\b\\1)",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.string.begin.ruby"
						}
					},
					"contentName": "source.lua",
					"end": "^\\s*\\2$\\n?",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.string.end.ruby"
						}
					},
					"name": "string.unquoted.heredoc.ruby",
					"patterns": [
						{
							"include": "#heredoc"
						},
						{
							"include": "#interpolated_ruby"
						},
						{
							"include": "source.lua"
						},
						{
							"include": "#escaped_char"
						}
					]
				}
			]
		},
		{
			"begin": "(?=(?><<[-~]([\"'`]?)((?:[_\\w]+_|)RUBY)\\b\\1))",
			"comment": "Heredoc with embedded ruby",
			"end": "(?!\\G)",
			"name": "meta.embedded.block.ruby",
			"patterns": [
				{
					"begin": "(?><<[-~]([\"'`]?)((?:[_\\w]+_|)RUBY)\\b\\1)",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.string.begin.ruby"
						}
					},
					"contentName": "source.ruby",
					"end": "^\\s*\\2$\\n?",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.string.end.ruby"
						}
					},
					"name": "string.unquoted.heredoc.ruby",
					"patterns": [
						{
							"include": "#heredoc"
						},
						{
							"include": "#interpolated_ruby"
						},
						{
							"include": "source.ruby"
						},
						{
							"include": "#escaped_char"
						}
					]
				}
			]
		},
		{
			"begin": "(?=(?><<[-~]([\"'`]?)((?:[_\\w]+_|)SLIM)\\b\\1))",
			"comment": "Heredoc with embedded slim",
			"end": "(?!\\G)",
			"name": "meta.embedded.block.slim",
			"patterns": [
				{
					"begin": "(?><<[-~]([\"'`]?)((?:[_\\w]+_|)SLIM)\\b\\1)",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.string.begin.ruby"
						}
					},
					"contentName": "text.slim",
					"end": "^\\s*\\2$\\n?",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.string.end.ruby"
						}
					},
					"name": "string.unquoted.heredoc.ruby",
					"patterns": [
						{
							"include": "#heredoc"
						},
						{
							"include": "#interpolated_ruby"
						},
						{
							"include": "text.slim"
						},
						{
							"include": "#escaped_char"
						}
					]
				}
			]
		},
		{
			"begin": "(?>=\\s*<<([\"'`]?)(\\w+)\\1)",
			"beginCaptures": {
				"0": {
					"name": "punctuation.definition.string.begin.ruby"
				}
			},
			"end": "^\\2$",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.string.end.ruby"
				}
			},
			"name": "string.unquoted.heredoc.ruby",
			"patterns": [
				{
					"include": "#heredoc"
				},
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				}
			]
		},
		{
			"begin": "(?>((<<[-~]([\"'`]?)(\\w+)\\3,\\s?)*<<[-~]([\"'`]?)(\\w+)\\5))(.*)",
			"beginCaptures": {
				"1": {
					"name": "punctuation.definition.string.begin.ruby"
				},
				"7": {
					"patterns": [
						{
							"include": "source.ruby"
						}
					]
				}
			},
			"comment": "heredoc with multiple inputs and indented terminator",
			"end": "^\\s*\\6$",
			"endCaptures": {
				"0": {
					"name": "punctuation.definition.string.end.ruby"
				}
			},
			"name": "string.unquoted.heredoc.ruby",
			"patterns": [
				{
					"include": "#heredoc"
				},
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				}
			]
		},
		{
			"begin": "(?<={|{\\s|[^A-Za-z0-9_]do|^do|[^A-Za-z0-9_]do\\s|^do\\s)(\\|)",
			"name": "meta.block.parameters.ruby",
			"captures": {
				"1": {
					"name": "punctuation.separator.variable.ruby"
				}
			},
			"end": "(?<!\\|)(\\|)(?!\\|)",
			"patterns": [
				{
					"begin": "(?![\\s,|(])",
					"end": "(?=,|\\|\\s*)",
					"patterns": [
						{
							"match": "\\G([&*]?)([a-zA-Z][\\w_]*)|(_[\\w_]*)",
							"captures": {
								"1": {
									"name": "storage.type.variable.ruby"
								},
								"2": {
									"name": "variable.other.block.ruby"
								},
								"3": {
									"name": "variable.other.block.unused.ruby variable.other.constant.ruby"
								}
							}
						}
					]
				},
				{
					"match": ",",
					"name": "punctuation.separator.variable.ruby"
				}
			]
		},
		{
			"match": "=>",
			"name": "punctuation.separator.key-value"
		},
		{
			"match": "->",
			"name": "support.function.kernel.ruby"
		},
		{
			"match": "<<=|%=|&{1,2}=|\\*=|\\*\\*=|\\+=|-=|\\^=|\\|{1,2}=|<<",
			"name": "keyword.operator.assignment.augmented.ruby"
		},
		{
			"match": "<=>|<(?!<|=)|>(?!<|=|>)|<=|>=|===|==|=~|!=|!~|(?<=[ \\t])\\?",
			"name": "keyword.operator.comparison.ruby"
		},
		{
			"match": "(?<!\\.)\\b(and|not|or)\\b(?![?!])",
			"name": "keyword.operator.logical.ruby"
		},
		{
			"match": "(?<=^|[ \\t!])!|&&|\\|\\||\\^",
			"name": "keyword.operator.logical.ruby"
		},
		{
			"comment": "Safe navigation operator",
			"match": "(&\\.)\\s*(?![A-Z])",
			"captures": {
				"1": {
					"name": "keyword.operator.logical.ruby"
				}
			}
		},
		{
			"match": "(%|&|\\*\\*|\\*|\\+|-|/)",
			"name": "keyword.operator.arithmetic.ruby"
		},
		{
			"match": "=",
			"name": "keyword.operator.assignment.ruby"
		},
		{
			"match": "\\||~|>>",
			"name": "keyword.operator.other.ruby"
		},
		{
			"match": ";",
			"name": "punctuation.separator.statement.ruby"
		},
		{
			"match": ",",
			"name": "punctuation.separator.object.ruby"
		},
		{
			"comment": "Mark as namespace separator if double colons followed by capital letter",
			"match": "(::)\\s*(?=[A-Z])",
			"captures": {
				"1": {
					"name": "punctuation.separator.namespace.ruby"
				}
			}
		},
		{
			"comment": "Mark as method separator if double colons not followed by capital letter",
			"match": "(\\.|::)\\s*(?![A-Z])",
			"captures": {
				"1": {
					"name": "punctuation.separator.method.ruby"
				}
			}
		},
		{
			"comment": "Must come after method and constant separators to prefer double colons",
			"match": ":",
			"name": "punctuation.separator.other.ruby"
		},
		{
			"match": "{",
			"name": "punctuation.section.scope.begin.ruby"
		},
		{
			"match": "}",
			"name": "punctuation.section.scope.end.ruby"
		},
		{
			"match": "\\[",
			"name": "punctuation.section.array.begin.ruby"
		},
		{
			"match": "]",
			"name": "punctuation.section.array.end.ruby"
		},
		{
			"match": "\\(|\\)",
			"name": "punctuation.section.function.ruby"
		},
		{
			"name": "meta.function-call.ruby",
			"begin": "(?<=[^\\.]\\.|::)(?=[a-zA-Z][a-zA-Z0-9_!?]*[^a-zA-Z0-9_!?])",
			"end": "(?<=[a-zA-Z0-9_!?])(?=[^a-zA-Z0-9_!?])",
			"patterns": [
				{
					"include": "#known_function_names"
				},
				{
					"name": "entity.name.function.ruby",
					"match": "([a-zA-Z][a-zA-Z0-9_!?]*)(?=[^a-zA-Z0-9_!?])"
				}
			]
		},
		{
			"begin": "(?=[a-zA-Z0-9_!?]+\\()",
			"end": "(?<=\\))",
			"name": "meta.function-call.ruby",
			"patterns": [
				{
					"include": "#known_function_names"
				},
				{
					"match": "([a-zA-Z0-9_!?]+)((?=\\()|([!?]))",
					"name": "entity.name.function.ruby"
				},
				{
					"include": "$self"
				}
			]
		},
		{
			"comment": "This is kindof experimental. There really is no way to perfectly match all regular variables, but you can pretty well assume that any normal word in certain curcumstances that haven't already been scoped as something else are probably variables, and the advantages beat the potential errors",
			"match": "((?<=\\W)\\b|^)\\w+\\b(?=\\s*([\\]\\)\\}\\=\\+\\-\\*\\/\\^\\$\\,\\.\\&]|<\\s|<<[\\s|\\.])?)",
			"name": "variable.other.ruby"
		}
	],
	"repository": {
		"escaped_char": {
			"match": "\\\\(?:[0-7]{1,3}|x[\\da-fA-F]{1,2}|.)",
			"name": "constant.character.escape.ruby"
		},
		"heredoc": {
			"begin": "^<<[-~]?\\w+",
			"end": "$",
			"patterns": [
				{
					"include": "$self"
				}
			]
		},
		"interpolated_ruby": {
			"patterns": [
				{
					"begin": "#{",
					"beginCaptures": {
						"0": {
							"name": "punctuation.section.embedded.begin.ruby"
						}
					},
					"contentName": "source.ruby",
					"end": "}",
					"endCaptures": {
						"0": {
							"name": "punctuation.section.embedded.end.ruby"
						}
					},
					"name": "meta.embedded.line.ruby",
					"patterns": [
						{
							"include": "#nest_curly_and_self"
						},
						{
							"include": "$self"
						}
					]
				},
				{
					"captures": {
						"1": {
							"name": "punctuation.definition.variable.ruby"
						}
					},
					"match": "(#@)[a-zA-Z_]\\w*",
					"name": "variable.other.readwrite.instance.ruby"
				},
				{
					"captures": {
						"1": {
							"name": "punctuation.definition.variable.ruby"
						}
					},
					"match": "(#@@)[a-zA-Z_]\\w*",
					"name": "variable.other.readwrite.class.ruby"
				},
				{
					"captures": {
						"1": {
							"name": "punctuation.definition.variable.ruby"
						}
					},
					"match": "(#\\$)[a-zA-Z_]\\w*",
					"name": "variable.other.readwrite.global.ruby"
				}
			]
		},
		"nest_brackets": {
			"begin": "\\[",
			"captures": {
				"0": {
					"name": "punctuation.section.scope.ruby"
				}
			},
			"end": "]",
			"patterns": [
				{
					"include": "#nest_brackets"
				}
			]
		},
		"nest_brackets_i": {
			"begin": "\\[",
			"captures": {
				"0": {
					"name": "punctuation.section.scope.ruby"
				}
			},
			"end": "]",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				},
				{
					"include": "#nest_brackets_i"
				}
			]
		},
		"nest_brackets_r": {
			"begin": "\\[",
			"captures": {
				"0": {
					"name": "punctuation.section.scope.ruby"
				}
			},
			"end": "]",
			"patterns": [
				{
					"include": "#regex_sub"
				},
				{
					"include": "#nest_brackets_r"
				}
			]
		},
		"nest_curly": {
			"begin": "{",
			"captures": {
				"0": {
					"name": "punctuation.section.scope.ruby"
				}
			},
			"end": "}",
			"patterns": [
				{
					"include": "#nest_curly"
				}
			]
		},
		"nest_curly_and_self": {
			"patterns": [
				{
					"begin": "{",
					"captures": {
						"0": {
							"name": "punctuation.section.scope.ruby"
						}
					},
					"end": "}",
					"patterns": [
						{
							"include": "#nest_curly_and_self"
						}
					]
				},
				{
					"include": "$self"
				}
			]
		},
		"nest_curly_i": {
			"begin": "{",
			"captures": {
				"0": {
					"name": "punctuation.section.scope.ruby"
				}
			},
			"end": "}",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				},
				{
					"include": "#nest_curly_i"
				}
			]
		},
		"nest_curly_r": {
			"begin": "{",
			"captures": {
				"0": {
					"name": "punctuation.section.scope.ruby"
				}
			},
			"end": "}",
			"patterns": [
				{
					"include": "#regex_sub"
				},
				{
					"include": "#nest_curly_r"
				}
			]
		},
		"nest_ltgt": {
			"begin": "<",
			"captures": {
				"0": {
					"name": "punctuation.section.scope.ruby"
				}
			},
			"end": ">",
			"patterns": [
				{
					"include": "#nest_ltgt"
				}
			]
		},
		"nest_ltgt_i": {
			"begin": "<",
			"captures": {
				"0": {
					"name": "punctuation.section.scope.ruby"
				}
			},
			"end": ">",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				},
				{
					"include": "#nest_ltgt_i"
				}
			]
		},
		"nest_ltgt_r": {
			"begin": "<",
			"captures": {
				"0": {
					"name": "punctuation.section.scope.ruby"
				}
			},
			"end": ">",
			"patterns": [
				{
					"include": "#regex_sub"
				},
				{
					"include": "#nest_ltgt_r"
				}
			]
		},
		"nest_parens": {
			"begin": "\\(",
			"captures": {
				"0": {
					"name": "punctuation.section.scope.ruby"
				}
			},
			"end": "\\)",
			"patterns": [
				{
					"include": "#nest_parens"
				}
			]
		},
		"nest_parens_i": {
			"begin": "\\(",
			"captures": {
				"0": {
					"name": "punctuation.section.scope.ruby"
				}
			},
			"end": "\\)",
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				},
				{
					"include": "#nest_parens_i"
				}
			]
		},
		"nest_parens_r": {
			"begin": "\\(",
			"captures": {
				"0": {
					"name": "punctuation.section.scope.ruby"
				}
			},
			"end": "\\)",
			"patterns": [
				{
					"include": "#regex_sub"
				},
				{
					"include": "#nest_parens_r"
				}
			]
		},
		"regex_sub": {
			"patterns": [
				{
					"include": "#interpolated_ruby"
				},
				{
					"include": "#escaped_char"
				},
				{
					"captures": {
						"1": {
							"name": "punctuation.definition.arbitrary-repetition.ruby"
						},
						"3": {
							"name": "punctuation.definition.arbitrary-repetition.ruby"
						}
					},
					"match": "({)\\d+(,\\d+)?(})",
					"name": "string.regexp.arbitrary-repetition.ruby"
				},
				{
					"begin": "\\[(?:\\^?])?",
					"captures": {
						"0": {
							"name": "punctuation.definition.character-class.ruby"
						}
					},
					"end": "]",
					"name": "string.regexp.character-class.ruby",
					"patterns": [
						{
							"include": "#escaped_char"
						}
					]
				},
				{
					"begin": "\\(\\?#",
					"beginCaptures": {
						"0": {
							"name": "punctuation.definition.comment.begin.ruby"
						}
					},
					"end": "\\)",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.comment.end.ruby"
						}
					},
					"name": "comment.line.number-sign.ruby",
					"patterns": [
						{
							"include": "#escaped_char"
						}
					]
				},
				{
					"begin": "\\(",
					"captures": {
						"0": {
							"name": "punctuation.definition.group.ruby"
						}
					},
					"end": "\\)",
					"name": "string.regexp.group.ruby",
					"patterns": [
						{
							"include": "#regex_sub"
						}
					]
				},
				{
					"begin": "(?<=^|\\s)(#)\\s(?=[[a-zA-Z0-9,. \\t?!-][^\\x{00}-\\x{7F}]]*$)",
					"beginCaptures": {
						"1": {
							"name": "punctuation.definition.comment.ruby"
						}
					},
					"comment": "We are restrictive in what we allow to go after the comment character to avoid false positives, since the availability of comments depend on regexp flags.",
					"end": "$\\n?",
					"endCaptures": {
						"0": {
							"name": "punctuation.definition.comment.ruby"
						}
					},
					"name": "comment.line.number-sign.ruby"
				}
			]
		},
		"yard": {
			"name": "comment.line.yard.ruby",
			"patterns": [
				{
					"include": "#yard_comment"
				},
				{
					"include": "#yard_name_types"
				},
				{
					"include": "#yard_param_types"
				},
				{
					"include": "#yard_tag"
				},
				{
					"include": "#yard_types"
				},
				{
					"include": "#yard_directive"
				}
			]
		},
		"yard_comment": {
			"comment": "For YARD tags that follow the tag-comment pattern",
			"begin": "^(\\s*)(#)(\\s*)(@)(abstract|api|author|deprecated|example|macro|note|overload|since|todo|version)(?=\\s|$)",
			"beginCaptures": {
				"1": {
					"name": "comment.line.yard.ruby"
				},
				"2": {
					"name": "punctuation.definition.comment.ruby"
				},
				"3": {
					"name": "comment.line.yard.ruby"
				},
				"4": {
					"name": "comment.line.keyword.punctuation.yard.ruby"
				},
				"5": {
					"name": "comment.line.keyword.yard.ruby"
				}
			},
			"end": "^(?!\\s*#\\3\\s{2,})",
			"contentName": "comment.line.string.yard.ruby",
			"name": "comment.line.number-sign.ruby",
			"patterns": [
				{
					"include": "#yard"
				},
				{
					"include": "#yard_continuation"
				}
			]
		},
		"yard_name_types": {
			"comment": "For YARD tags that follow the tag-name-types-comment pattern",
			"begin": "^(\\s*)(#)(\\s*)(@)(attr|attr_reader|attr_writer|see|yieldparam)(?=\\s)(\\s+([a-z_][a-zA-Z_]*))?(\\s+((\\[).+(])))?",
			"beginCaptures": {
				"1": {
					"name": "comment.line.yard.ruby"
				},
				"2": {
					"name": "punctuation.definition.comment.ruby"
				},
				"3": {
					"name": "comment.line.yard.ruby"
				},
				"4": {
					"name": "comment.line.keyword.punctuation.yard.ruby"
				},
				"5": {
					"name": "comment.line.keyword.yard.ruby"
				},
				"6": {
					"name": "comment.line.yard.ruby"
				},
				"7": {
					"name": "comment.line.parameter.yard.ruby"
				},
				"8": {
					"name": "comment.line.yard.ruby"
				},
				"9": {
					"name": "comment.line.type.yard.ruby"
				},
				"10": {
					"name": "comment.line.punctuation.yard.ruby"
				},
				"11": {
					"name": "comment.line.punctuation.yard.ruby"
				}
			},
			"end": "^(?!\\s*#\\3\\s{2,})",
			"contentName": "comment.line.string.yard.ruby",
			"name": "comment.line.number-sign.ruby",
			"patterns": [
				{
					"include": "#yard"
				},
				{
					"include": "#yard_continuation"
				}
			]
		},
		"yard_param_types": {
			"comment": "For YARD tags that follow the tag-param-types-comment pattern",
			"begin": "^(\\s*)(#)(\\s*)(@)(option|param)(?=\\s)(\\s+([a-z_][a-zA-Z_]*:?))?(\\s+((\\[).+(])))?(\\s+(:[a-z_][a-zA-Z_]*))?",
			"beginCaptures": {
				"1": {
					"name": "comment.line.yard.ruby"
				},
				"2": {
					"name": "punctuation.definition.comment.ruby"
				},
				"3": {
					"name": "comment.line.yard.ruby"
				},
				"4": {
					"name": "comment.line.keyword.punctuation.yard.ruby"
				},
				"5": {
					"name": "comment.line.keyword.yard.ruby"
				},
				"6": {
					"name": "comment.line.yard.ruby"
				},
				"7": {
					"name": "comment.line.parameter.yard.ruby"
				},
				"8": {
					"name": "comment.line.yard.ruby"
				},
				"9": {
					"name": "comment.line.type.yard.ruby"
				},
				"10": {
					"name": "comment.line.punctuation.yard.ruby"
				},
				"11": {
					"name": "comment.line.punctuation.yard.ruby"
				},
				"12": {
					"name": "comment.line.punctuation.yard.ruby"
				},
				"13": {
					"name": "comment.line.keyword.yard.ruby"
				},
				"14": {
					"name": "comment.line.punctuation.yard.ruby"
				}
			},
			"end": "^(?!\\s*#\\3\\s{2,})",
			"contentName": "comment.line.string.yard.ruby",
			"name": "comment.line.number-sign.ruby",
			"patterns": [
				{
					"include": "#yard"
				},
				{
					"include": "#yard_continuation"
				}
			]
		},
		"yard_tag": {
			"comment": "For YARD tags that are just the tag",
			"match": "^(\\s*)(#)(\\s*)(@)(private)$",
			"captures": {
				"1": {
					"name": "comment.line.yard.ruby"
				},
				"2": {
					"name": "punctuation.definition.comment.ruby"
				},
				"3": {
					"name": "comment.line.yard.ruby"
				},
				"4": {
					"name": "comment.line.keyword.punctuation.yard.ruby"
				},
				"5": {
					"name": "comment.line.keyword.yard.ruby"
				}
			},
			"name": "comment.line.number-sign.ruby"
		},
		"yard_types": {
			"comment": "For YARD tags that follow the tag-types-comment pattern",
			"begin": "^(\\s*)(#)(\\s*)(@)(raise|return|yield(?:return)?)(?=\\s)(\\s+((\\[).+(])))?",
			"beginCaptures": {
				"1": {
					"name": "comment.line.yard.ruby"
				},
				"2": {
					"name": "punctuation.definition.comment.ruby"
				},
				"3": {
					"name": "comment.line.yard.ruby"
				},
				"4": {
					"name": "comment.line.keyword.punctuation.yard.ruby"
				},
				"5": {
					"name": "comment.line.keyword.yard.ruby"
				},
				"6": {
					"name": "comment.line.yard.ruby"
				},
				"7": {
					"name": "comment.line.type.yard.ruby"
				},
				"8": {
					"name": "comment.line.punctuation.yard.ruby"
				},
				"9": {
					"name": "comment.line.punctuation.yard.ruby"
				}
			},
			"end": "^(?!\\s*#\\3\\s{2,})",
			"contentName": "comment.line.string.yard.ruby",
			"name": "comment.line.number-sign.ruby",
			"patterns": [
				{
					"include": "#yard"
				},
				{
					"include": "#yard_continuation"
				}
			]
		},
		"yard_directive": {
			"comment": "For YARD directives",
			"begin": "^(\\s*)(#)(\\s*)(@!)(attribute|endgroup|group|macro|method|parse|scope|visibility)(\\s+((\\[).+(])))?(?=\\s)",
			"beginCaptures": {
				"1": {
					"name": "comment.line.yard.ruby"
				},
				"2": {
					"name": "punctuation.definition.comment.ruby"
				},
				"3": {
					"name": "comment.line.yard.ruby"
				},
				"4": {
					"name": "comment.line.keyword.punctuation.yard.ruby"
				},
				"5": {
					"name": "comment.line.keyword.yard.ruby"
				},
				"6": {
					"name": "comment.line.yard.ruby"
				},
				"7": {
					"name": "comment.line.type.yard.ruby"
				},
				"8": {
					"name": "comment.line.punctuation.yard.ruby"
				},
				"9": {
					"name": "comment.line.punctuation.yard.ruby"
				}
			},
			"end": "^(?!\\s*#\\3\\s{2,})",
			"contentName": "comment.line.string.yard.ruby",
			"name": "comment.line.number-sign.ruby",
			"patterns": [
				{
					"include": "#yard"
				},
				{
					"include": "#yard_continuation"
				}
			]
		},
		"yard_continuation": {
			"match": "^\\s*#",
			"name": "punctuation.definition.comment.ruby"
		},
		"known_function_names": {
			"name": "support.function.core.ruby",
			"match": "\\b(abort_on_exception=|absolute\\?|acos!|acosh!|add!|add\\?|alive\\?|all\\?|any\\?|asin!|asinh!|async=|atan!|atan2!|atanh!|attributes=|autoload\\?|avail_out=|beginning_of_line\\?|between\\?|block_given\\?|blockdev\\?|bol\\?|capitalize!|casefold\\?|changed\\?|chardev\\?|charset=|chomp!|chop!|close!|closed\\?|closed_read\\?|closed_write\\?|codepage=|collect!|comment=|compact!|const_defined\\?|coredump\\?|cos!|cosh!|critical=|data=|dataType=|datetime_format=|debug\\?|default=|delete!|delete\\?|directory\\?|dn=|downcase!|dst\\?|egid=|eid=|empty\\?|enclosed\\?|end\\?|ended\\?|eof\\?|eos\\?|eql\\?|eqn\\?|equal\\?|error\\?|event\\?|exclude_end\\?|executable\\?|executable_real\\?|exist\\?|exists\\?|exit!|exited\\?|euid=|exp!|extensions=|fatal\\?|file\\?|filter=|finished\\?|finite\\?|flatten!|fnmatch\\?|fragment=|frozen\\?|fu_have_symlink\\?|fu_world_writable\\?|gid=|gmt\\?|gregorian_leap\\?|groups=|grpowned\\?|gsub!|has_key\\?|has_value\\?|headers=|hierarchical\\?|host=|identical\\?|include\\?|infinite\\?|info\\?|input\\?|instance_of\\?|integer\\?|is_a\\?|iterator\\?|julian_leap\\?|key\\?|kind_of\\?|leap\\?|level=|lineno=|locked\\?|log!|log10!|log=|lstrip!|map!|match\\?|matched\\?|max=|maxgroups=|member\\?|merge!|method_defined\\?|mountpoint\\?|multipart\\?|mtime=|multipart\\?|nan\\?|new!|next!|next\\?|nil\\?|nodeTypedValue=|nodeValue=|nonzero\\?|normalize!|ns\\?|ondataavailable=|onreadystatechange=|ontransformnode=|opaque=|optional\\?|orig_name=|os\\?|output\\?|owned\\?|params=|password=|path=|pipe\\?|pointer=|port=|pos=|power!|preserveWhiteSpace=|priority=|private_method_defined\\?|proper_subset\\?|proper_superset\\?|protected_method_defined\\?|public_method_defined\\?|query=|re_exchangeable\\?|readable\\?|readable_real\\?|registry=|regular\\?|reject!|relative\\?|resolveExternals=|respond_to\\?|rest\\?|retval\\?|reverse!|root\\?|rstrip!|run\\?|run=|scheme=|scope=|secure=|setgid\\?|setuid\\?|sid_available\\?|signaled\\?|sin!|singular\\?|sinh!|size\\?|slice!|socket\\?|sort!|sqrt!|square\\?|squeeze!|sticky\\?|stop\\?|stopped\\?|stream_end\\?|string=|strip!|sub!|subset\\?|succ!|success\\?|superset\\?|swapcase!|symlink\\?|sync=|sync_point\\?|tainted\\?|tan!|tanh!|text=|to=|tr!|tr_s!|tty\\?|typecode=|uid=|uniq!|upcase!|uptodate\\?|url=|user=|userinfo=|utc\\?|valid_civil\\?|valid_commercial\\?|valid_jd\\?|valid_ordinal\\?|valid_time\\?|validateOnParse=|value=|value\\?|visible\\?|warn\\?|writable\\?|writable_real\\?|zero\\?)|\\b(__getobj__|__id__|__init__|__send__|__setobj__|_dump|_getproperty|_id2ref|_invoke|_load|_setproperty|abbrev|abort_on_exception|abort|abs2|absoluteChildNumber|absolute|abs|acosh|acos|add_builtin_type|add_domain_type|add_finalizer|add_observer|add_private_type|add_ruby_type|add|adler32|adler|ajd_to_amjd|ajd_to_jd|ajd|a|all_symbols|all_waits|allocate|amjd_to_ajd|amjd|ancestorChildNumber|ancestors|angle|appendChild|appendData|append_features|args|arg|arity|asctime|asinh|asin|assoc|async|at_exit|atan2|atanh|atan|atime|attributes|at|autoload|avail_in|avail_out|b64encode|backtrace|baseName|basename|base|benchmark|binding|bind|binmode|blksize|blockquote|blocks|bmbm|bm|broadcast|build2|build|call_finalizer|callcc|caller|call|capitalize|caption|captures|casecmp|cd|ceil|center|change_privilege|changed|charset_map|charset|chdir|check_until|checkbox_group|checkbox|check|childNodes|childNumber|children|chmod_R|chmod|chomp|chop|chown_R|chown|chroot|chr|civil_to_jd|civil|class_eval|class_name|class_variable_get|class_variable_set|class_variables|classify|class|cleanpath|clear|cloneNode|clone|close_read|close_write|close|cmp|codepage|coerce|collect2|collect|column_size|column_vector|column_vectors|columns|column|comment|commercial_to_jd|commercial|commit|compact|compare_by_row_vectors|compare_by|compare_file|compare_stream|compile|component_ary|component|concat|conj|conjugate|connect|const_get|const_load|const_missing|const_set|constants|conv|copy_entry|copy_file|copy_stream|copy|cosh|cos|count_observers|count|covector|cp_r|cp|crc32|crc_table|crc|createAttribute|createCDATASection|createComment|createDocumentFragment|createElement|createEntityReference|createNode|createProcessingInstruction|createTextNode|create_docfile|create_win32ole_makefile|critical|crypt|ctime|current|cwday|cweek|cwyear|dataType|data_type|data|datetime_format|day_fraction|day_fraction_to_time|day|debug|decode64|decode_b|decode|def_delegator|def_delegators|def_instance_delegator|def_instance_delegators|def_singleton_delegator|def_singleton_delegators|default_handler|default_port|default_proc|default|define_class|define_finalizer|define_define_define_instance_variables|define_method|define_method_missing|define_module|definition|deflate|deleteData|delete_at|delete_if|delete_observer|delete_observers|delete|denominator|depth|deq|detach|detect|detect_implicit|determinant|det|dev_major|dev_minor|dev|diagonal|difference|dir_foreach|dirname|disable|dispid|display|divide|divmod|div|dn|doctype|documentElement|downcase|downto|dump_stream|dump|dup|each2|each_byte|each_cons|each_document|each_entry|each_filename|each_index|each_key|each_line|each_node|each_object|each_pair|each_slice|each_value|each_with_index|each|eid|elements|emitter|enable|enclose|encode64|encode|end|england|enq|entities|entries|enum_cons|enum_for|enum_slice|enum_with_index|eof|erfc|erf|errno|errorCode|error|escapeElement|escapeHTML|escape|euid|eval|event_interface|exception|exclusive|exclusive_unlock|exec|exit_value|exitstatus|exit|expand_path|exp|extend_object|extended|extensions|extname|extract|failed|fail|fatal|fcntl|fetch|file_field|fileno|filepos|fill|filter|finalizers|find_all|find|finish|first|firstChild|flatten_merge|flatten|flock|floor|flush_next_in|flush_next_out|flush|fnmatch|for_fd|foreachline|foreach|fork|format|formatDate|formatIndex|formatNumber|formatTime|form|freeze|frexp|fsync|ftype|garbage_collect|gcdlcm|gcd|generate_args|generate_argtype|generate_argtypes|generate_class|generate_constants|generate_func_methods|generate_method_args_help|generate_method_body|generate_method_help|generate_methods|generate_method|generate_properties_with_args|generate_propget_methods|generate_propput_methods|generate_propputref_methods|generate|generic_parser|getAllResponseHeaders|getAttribute|getAttributeNode|getElementsByTagName|getNamedItem|getQualifiedItem|getResponseHeader|get_byte|getbyte|getch|getc|getegid|geteuid|getgid|getgm|getlocal|getpgid|getpgrp|getpriority|gets|getuid|getutc|getwd|gid|global_variables|glob|gmt_offset|gmtime|gmtoff|gm|grant_privilege|gregorian|grep|groups|group|gsub|guess1|guess2|guess_old|guess|guid|handler1|handler2|handler3|hasChildNodes|hasFeature|hash|header|helpcontext|helpfile|helpstring|hex|hidden|hour|html_escape|html|httpdate|hypot|h|iconv|id2name|identity|id|imag|image_button|image|img|implementation|im|included_modules|included|indexes|index|indices|induced_from|inflate|info|inherited|init_elements|initgroups|initialize_copy|inject|inner_product|ino|insertBefore|insertData|insert|inspect|install|instance_eval|instance_method|instance_methods|instance_variable_get|instance_variable_set|instance_variables|intern|intersection|inverse|inverse_from|invert|invkind|invoke|invoke_kind|inv|ioctl|isatty|isdst|iseuc|iso8601|issetugid|issjis|isutf8|italy|item|jd_to_ajd|jd_to_civil|jd_to_commercial|jd_to_ld|jd_to_mjd|jd_to_ordinal|jd_to_wday|jd|join_nowait|join|julian|kcode|kconv|keys|kill|lambda|lastChild|last_match|last|lchmod|lchown|lcm|ld_to_jd|ldexp|ld|length|level|lineno|linepos|(?<=\\.)line|link|listup|list|ljust|ln_s|ln_sf|ln|loadXML|load_documents|load_file|load_stream|load|local_variables|localtime|local|lock|log10|log|lstat|lstrip|main|major_version|make_link|make_symlink|makedirs|map2|map|marshal_dump|marshal_load|matched|matched_size|matchedsize|match|maxgroups|max|mday|measure|members|memberwise|merge|message_message|method_added|method_missing|method_removed|method_undefined|methods|method|minor|minor_version|min|mjd_to_jd|mjd|mkdir_p|mkdir|mkpath|mktime|mode|module_eval|modulo|month|mon|move|mtime|multipart_form|must_C_version|mv|namespaceURI|name|navigate|nesting|new2|new_start|nextNode|nextSibling|next_wait|next|nitems|nkf|nlink|nodeFromID|nodeName|nodeType|nodeTypeString|nodeTypedValue|nodeValue|normalize|notationName|notations|notify_observers|now|num_waiting|numerator|object_id|object_maker|oct|offset_vtbl|offset|ole_classes|ole_free|ole_func_methods|ole_get_methods|ole_method|ole_method_help|ole_methods|ole_obj_help|ole_put_methods|ole_reference_count|ole_show_help|ole_type_detail|ole_type|oletypelib_name|on_event_with_outargs|on_event|ondataavailable|onreadystatechange|opendir|open|options|ordinal_to_jd|ordinal|orig_name|os_code|out|ownerDocument|pack|params|parentNode|parent|parseError|parse_documents|parse_file|parsed|parser|parse|partition|password|password_field|pass|path|peek|peep|pid|pipe|pointer|polar|popen|popup_menu|pop|post_match|pos|ppid|pre_match|prec_f|prec_i|prec|prefix|preserveWhiteSpace|pretty|previousSibling|printf|print|priority|private_class_method|private_instance_methods|private_methods|proc|progids|progid|protected_instance_methods|protected_methods|prune|publicId|public_class_method|public_instance_methods|public_methods|push|putc|puts|pwd|p|quick_emit|quote|quo|radio_button|radio_group|rand|rank|rassoc|raw_cookie|raw_cookie2|rdev_major|rdev_minor|rdev|rdiv|re_exchange|read_type_class|readchar|readlines|readline|readlink|readpartial|readyState|read|realpath|realtime|real|reason|reduce|regexp|rehash|reject|relative_path_from|remainder|removeAttribute|removeAttributeNode|removeChild|removeNamedItem|removeQualifiedItem|remove_class_variable|remove_const|remove_dir|remove_entry_secure|remove_entry|remove_file|remove_finalizer|remove_instance_variable|remove_method|remove|rename|reopen|replaceChild|replaceData|replace|request_uri|require|reset|resolveExternals|resolver|responseBody|responseStream|responseText|responseXML|rest_size|restore|restsize|rest|result|return_type_detail|return_type|return_vtype|reverse_each|reverse|rewind|rfc1123_date|rfc2822|rfc822|rid|rindex|rjust|rm_f|rm_rf|rm_r|rmdir|rmtree|rm|roots|root|round|route_from|route_to|row_size|row_vector|row_vectors|rows|row|rpower|rstrip|run|r|safe_level|safe_unlink|save(?!!)|scalar|scan_full|scan_until|scan|scope|scrolling_list|search_full|sec|seek|selectNodes|selectSingleNode|select|send|setAttribute|setAttributeNode|setNamedItem|setRequestHeader|set_attributes|set_backtrace|set_dictionary|set_dn|set_eoutvar|set_extensions|set_filter|set_fragment|set_headers|set_host|set_log|set_opaque|set_password|set_path|set_port|set_query|set_registry|set_scheme|set_scope|set_to|set_trace_func|set_typecode|set_user|set_userinfo|setegid|seteuid|setgid|setpgid|setpgrp|setpriority|setproperty|setregid|setresgid|setresuid|setreuid|setrgid|setruid|setsid|setuid|setup|shellwords|shift|signal|sin|singleton_method_added|singleton_method_removed|singleton_method_undefined|singleton_methods|sinh|size_opt_params|size_params|size|skip_until|skip|sleep|slice|sort_by|sort|source|specified|split|splitText|sprintf|sqrt|squeeze|srand|srcText|src_type|start|status|statusText|stat|step|stop_msg_stopsig|stop|store|strftime|string|strip|strptime|sub|submit|substringData|subtract|succ|success|sum|superclass|swapcase|switch|symlink|synchronize|sync|syscall|sysopen|sysread|sysseek|systemId|system|syswrite|tagName|tagurize|taint|tanh|tan|target|teardown|tell|terminate|termsig|test__invoke|test_bracket_equal_with_arg|test_class_to_s|test_const_CP_ACP|test_const_CP_MACCP|test_const_CP_OEMCP|test_const_CP_SYMBOL|test_const_CP_THREAD_ACP|test_const_CP_UTF7|test_const_CP_UTF8|test_convert_bignum|test_dispid|test_each|test_event|test_event_interface|test_get_win32ole_object|test_helpcontext|test_helpfile|test_helpstring|test_input|test_invoke_kind|test_invoke|test_name|test_no_exist_property|test_offset_vtbl|test_ole_func_methods|test_ole_get_methods|test_ole_invoke_with_named_arg|test_ole_invoke_with_named_arg_last|test_ole_method_help|test_ole_methods|test_ole_put_methods|test_ole_type|test_ole_type_detail|test_on_event|test_on_event2|test_on_event3|test_on_event4|test_openSchema|test_optional|test_output|test_return_type|test_return_type_detail|test_return_vtype|test_s_codepage|test_s_codepage_changed|test_s_codepage_set|test_s_connect|test_s_const_load|test_s_test_s_new_DCOM|test_s_new_from_clsid|test_s_ole_classes|test_s_progids|test_s_typelibs|test_setproperty|test_setproperty_bracket|test_setproperty_with_equal|test_src_type|test_to_s|test_typekind|test_value|test_variables|test_variant|test_visible|test|text_field|textarea|text|time_to_day_fraction|timeout|times|tmpdir|to_ary|to_a|to_enum|to_f|to_hash|to_int|to_io|to_i|to_mailtext|to_proc|to_rfc822text|to_r|to_set|to_str|to_sym|to_s|today|toeuc|tojis|tosjis|total_in|total_out|touch|toutf16|toutf8|tr_s|trace_var|trace|transaction|transfer|transformNode|transformNodeToObject|transpose|trap|truncate|try_implicit|try_lock|tr|tv_sec|tv_usec|typekind|typelibs|type|t|uid|umask|unbind|undef_method|undefine_finalizer|unescapeElement|unescapeHTML|unescape|ungetc|union|uniqueID|uniq|unknown|unlink|unlock|unpack|unscan|unshift|untaint|untrace_var|unused|upcase|update|upto|url_encode|url|use_registry|usec|userinfo|user|utc_offset|utc|utime|u|validateOnParse|values_at|values|value|variable_kind|variables|varkind|version|wait2|waitall|waitpid|waitpid2|wait|wakeup|warn|wday|wrap|write|xmlschema|xml|yday|year|yield|zero|zip|zlib_version|zone_offset|zone)\\b"
		}
	}
}
